{"version":3,"sources":["@photo-sphere-viewer/core","three","src/index.ts","src/EquirectangularVideoAdapter.ts","../shared/AbstractVideoAdapter.ts"],"sourcesContent":["module.exports = PhotoSphereViewer","module.exports = THREE","export { EquirectangularVideoAdapter } from './EquirectangularVideoAdapter';\nexport * from './model';\n","import type { TextureData, Viewer } from '@photo-sphere-viewer/core';\nimport { CONSTANTS, PSVError, utils } from '@photo-sphere-viewer/core';\nimport { MathUtils, Mesh, MeshBasicMaterial, SphereGeometry, VideoTexture } from 'three';\nimport { AbstractVideoAdapter } from '../../shared/AbstractVideoAdapter';\nimport { EquirectangularVideoAdapterConfig, EquirectangularVideoPanorama } from './model';\n\ntype EquirectangularMesh = Mesh<SphereGeometry, MeshBasicMaterial>;\ntype EquirectangularTexture = TextureData<VideoTexture, EquirectangularVideoPanorama>;\n\nconst getConfig = utils.getConfigParser<EquirectangularVideoAdapterConfig>(\n    {\n        resolution: 64,\n        autoplay: false,\n        muted: false,\n        blur: false,\n    },\n    {\n        resolution: (resolution) => {\n            if (!resolution || !MathUtils.isPowerOfTwo(resolution)) {\n                throw new PSVError('EquirectangularTilesAdapter resolution must be power of two');\n            }\n            return resolution;\n        },\n    }\n);\n\n/**\n * Adapter for equirectangular videos\n */\nexport class EquirectangularVideoAdapter extends AbstractVideoAdapter<EquirectangularVideoPanorama> {\n    static override readonly id = 'equirectangular-video';\n\n    protected override readonly config: EquirectangularVideoAdapterConfig;\n\n    private readonly SPHERE_SEGMENTS: number;\n    private readonly SPHERE_HORIZONTAL_SEGMENTS: number;\n\n    constructor(viewer: Viewer, config: EquirectangularVideoAdapterConfig) {\n        super(viewer);\n\n        this.config = getConfig(config);\n\n        this.SPHERE_SEGMENTS = this.config.resolution;\n        this.SPHERE_HORIZONTAL_SEGMENTS = this.SPHERE_SEGMENTS / 2;\n    }\n\n    override loadTexture(panorama: EquirectangularVideoPanorama): Promise<EquirectangularTexture> {\n        return super.loadTexture(panorama).then(({ texture }) => {\n            const video: HTMLVideoElement = texture.image;\n            const panoData = {\n                fullWidth: video.videoWidth,\n                fullHeight: video.videoHeight,\n                croppedWidth: video.videoWidth,\n                croppedHeight: video.videoHeight,\n                croppedX: 0,\n                croppedY: 0,\n                poseHeading: 0,\n                posePitch: 0,\n                poseRoll: 0,\n            };\n\n            return { panorama, texture, panoData };\n        });\n    }\n\n    createMesh(scale = 1): EquirectangularMesh {\n        const geometry = new SphereGeometry(\n            CONSTANTS.SPHERE_RADIUS * scale,\n            this.SPHERE_SEGMENTS,\n            this.SPHERE_HORIZONTAL_SEGMENTS,\n            -Math.PI / 2\n        ).scale(-1, 1, 1) as SphereGeometry;\n\n        const material = new MeshBasicMaterial();\n\n        return new Mesh(geometry, material);\n    }\n\n    setTexture(mesh: EquirectangularMesh, textureData: EquirectangularTexture) {\n        mesh.material.map?.dispose();\n        mesh.material.map = textureData.texture;\n\n        this.switchVideo(textureData.texture);\n    }\n}\n","import type { TextureData, Viewer } from '@photo-sphere-viewer/core';\nimport { AbstractAdapter, events, PSVError } from '@photo-sphere-viewer/core';\nimport { BufferGeometry, Material, Mesh, VideoTexture } from 'three';\n\nexport type AbstractVideoPanorama = {\n    source: string;\n};\n\nexport type AbstractVideoAdapterConfig = {\n    /**\n     * automatically start the video\n     * @default false\n     */\n    autoplay?: boolean;\n    /**\n     * initially mute the video\n     * @default false\n     */\n    muted?: boolean;\n};\n\ntype AbstractVideoMesh = Mesh<BufferGeometry, Material>;\ntype AbstractVideoTexture = TextureData<VideoTexture>;\n\n/**\n * Base video adapters class\n */\nexport abstract class AbstractVideoAdapter<TPanorama extends AbstractVideoPanorama> extends AbstractAdapter<\n    TPanorama,\n    VideoTexture\n> {\n    static override readonly supportsDownload = false;\n    static override readonly supportsOverlay = false;\n\n    protected abstract readonly config: AbstractVideoAdapterConfig;\n\n    private video: HTMLVideoElement;\n\n    constructor(viewer: Viewer) {\n        super(viewer);\n\n        this.viewer.addEventListener(events.BeforeRenderEvent.type, this);\n    }\n\n    override destroy() {\n        this.viewer.removeEventListener(events.BeforeRenderEvent.type, this);\n\n        this.__removeVideo();\n\n        super.destroy();\n    }\n\n    /**\n     * @internal\n     */\n    handleEvent(e: Event) {\n        if (e instanceof events.BeforeRenderEvent) {\n            this.viewer.needsUpdate();\n        }\n    }\n\n    override supportsPreload(): boolean {\n        return false;\n    }\n\n    override supportsTransition(): boolean {\n        return false;\n    }\n\n    loadTexture(panorama: AbstractVideoPanorama): Promise<AbstractVideoTexture> {\n        if (typeof panorama !== 'object' || !panorama.source) {\n            return Promise.reject(new PSVError('Invalid panorama configuration, are you using the right adapter?'));\n        }\n\n        if (!this.viewer.getPlugin('video')) {\n            return Promise.reject(new PSVError('Video adapters require VideoPlugin to be loaded too.'));\n        }\n\n        const video = this.__createVideo(panorama.source);\n\n        return this.__videoLoadPromise(video).then(() => {\n            const texture = new VideoTexture(video);\n            return { panorama, texture };\n        });\n    }\n\n    protected switchVideo(texture: VideoTexture) {\n        let currentTime;\n        let duration;\n        let paused = !this.config.autoplay;\n        let muted = this.config.muted;\n        let volume = 1;\n        if (this.video) {\n            ({ currentTime, duration, paused, muted, volume } = this.video);\n        }\n\n        this.__removeVideo();\n        this.video = texture.image;\n\n        // keep current time when switching resolution\n        if (this.video.duration === duration) {\n            this.video.currentTime = currentTime;\n        }\n\n        // keep volume\n        this.video.muted = muted;\n        this.video.volume = volume;\n\n        // play\n        if (!paused) {\n            this.video.play();\n        }\n    }\n\n    setTextureOpacity(mesh: AbstractVideoMesh, opacity: number) {\n        mesh.material.opacity = opacity;\n        mesh.material.transparent = opacity < 1;\n    }\n\n    setOverlay() {\n        throw new PSVError('VideoAdapter does not support overlay');\n    }\n\n    disposeTexture(textureData: AbstractVideoTexture) {\n        if (textureData.texture) {\n            const video: HTMLVideoElement = textureData.texture.image;\n            video.pause();\n            this.viewer.container.removeChild(video);\n        }\n        textureData.texture?.dispose();\n    }\n\n    private __removeVideo() {\n        if (this.video) {\n            this.video.pause();\n            this.viewer.container.removeChild(this.video);\n            delete this.video;\n        }\n    }\n\n    private __createVideo(src: string): HTMLVideoElement {\n        const video = document.createElement('video');\n        video.crossOrigin = this.viewer.config.withCredentials ? 'use-credentials' : 'anonymous';\n        video.loop = true;\n        video.playsInline = true;\n        video.style.display = 'none';\n        video.muted = this.config.muted;\n        video.src = src;\n        video.preload = 'metadata';\n\n        this.viewer.container.appendChild(video);\n\n        return video;\n    }\n\n    private __videoLoadPromise(video: HTMLVideoElement): Promise<void> {\n        return new Promise((resolve, reject) => {\n            const onLoaded = () => {\n                if (this.video && video.duration === this.video.duration) {\n                    resolve(this.__videoBufferPromise(video, this.video.currentTime));\n                } else {\n                    resolve();\n                }\n                video.removeEventListener('loadedmetadata', onLoaded);\n            };\n\n            const onError = (err: ErrorEvent) => {\n                reject(err);\n                video.removeEventListener('error', onError);\n            };\n\n            video.addEventListener('loadedmetadata', onLoaded);\n            video.addEventListener('error', onError);\n        });\n    }\n\n    private __videoBufferPromise(video: HTMLVideoElement, currentTime: number): Promise<void> {\n        return new Promise((resolve) => {\n            function onBuffer() {\n                const buffer = video.buffered;\n                for (let i = 0, l = buffer.length; i < l; i++) {\n                    if (buffer.start(i) <= video.currentTime && buffer.end(i) >= video.currentTime) {\n                        video.pause();\n                        video.removeEventListener('buffer', onBuffer);\n                        video.removeEventListener('progress', onBuffer);\n                        resolve();\n                        break;\n                    }\n                }\n            }\n\n            // try to reduce the switching time by preloading in advance\n            // FIXME find a better way ?\n            video.currentTime = Math.min(currentTime + 2000, video.duration);\n            video.muted = true;\n\n            video.addEventListener('buffer', onBuffer);\n            video.addEventListener('progress', onBuffer);\n\n            video.play();\n        });\n    }\n}\n"],"mappings":"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","names":["import_core","import_three"]}