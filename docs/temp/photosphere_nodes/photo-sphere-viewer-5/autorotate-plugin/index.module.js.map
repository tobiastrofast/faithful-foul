{"version":3,"sources":["../src/index.ts","../src/AutorotateButton.ts","../src/events.ts","../src/AutorotatePlugin.ts"],"sourcesContent":["import { DEFAULTS, registerButton } from '@photo-sphere-viewer/core';\nimport { AutorotateButton } from './AutorotateButton';\nimport * as events from './events';\n\nregisterButton(AutorotateButton, 'start');\nDEFAULTS.lang[AutorotateButton.id] = 'Automatic rotation';\n\nexport { AutorotatePlugin } from './AutorotatePlugin';\nexport * from './model';\nexport { events };\n","import type { Navbar } from '@photo-sphere-viewer/core';\nimport { AbstractButton } from '@photo-sphere-viewer/core';\nimport type { AutorotatePlugin } from './AutorotatePlugin';\nimport { AutorotateEvent } from './events';\nimport iconActive from './icons/play-active.svg';\nimport icon from './icons/play.svg';\n\nexport class AutorotateButton extends AbstractButton {\n    static override readonly id = 'autorotate';\n\n    private readonly plugin: AutorotatePlugin;\n\n    constructor(navbar: Navbar) {\n        super(navbar, {\n            className: 'psv-autorotate-button',\n            hoverScale: true,\n            collapsable: true,\n            tabbable: true,\n            icon: icon,\n            iconActive: iconActive,\n        });\n\n        this.plugin = this.viewer.getPlugin('autorotate');\n\n        this.plugin?.addEventListener(AutorotateEvent.type, this);\n    }\n\n    override destroy() {\n        this.plugin?.removeEventListener(AutorotateEvent.type, this);\n\n        super.destroy();\n    }\n\n    override isSupported() {\n        return !!this.plugin;\n    }\n\n    handleEvent(e: Event) {\n        if (e instanceof AutorotateEvent) {\n            this.toggleActive(e.autorotateEnabled);\n        }\n    }\n\n    onClick() {\n        if (this.plugin.isEnabled()) {\n            this.plugin.config.autostartOnIdle = false;\n        }\n        this.plugin.toggle();\n    }\n}\n","import { TypedEvent } from '@photo-sphere-viewer/core';\nimport type { AutorotatePlugin } from './AutorotatePlugin';\n\n/**\n * @event Triggered when the automatic rotation is enabled/disabled\n */\nexport class AutorotateEvent extends TypedEvent<AutorotatePlugin> {\n    static override readonly type = 'autorotate';\n    override type: 'autorotate';\n\n    /** @internal */\n    constructor(public readonly autorotateEnabled: boolean) {\n        super(AutorotateEvent.type);\n    }\n}\n\nexport type AutorotatePluginEvents = AutorotateEvent;\n","import type { ExtendedPosition, Position, Tooltip, Viewer } from '@photo-sphere-viewer/core';\nimport { AbstractConfigurablePlugin, CONSTANTS, events, PSVError, utils } from '@photo-sphere-viewer/core';\nimport type { MarkersPlugin } from '@photo-sphere-viewer/markers-plugin';\nimport type { VideoPlugin } from '@photo-sphere-viewer/video-plugin';\nimport { MathUtils, SplineCurve, Vector2 } from 'three';\nimport { AutorotateEvent, AutorotatePluginEvents } from './events';\nimport { AutorotateKeypoint, AutorotatePluginConfig, UpdatableAutorotatePluginConfig } from './model';\n// import { debugCurve } from '../../shared/autorotate-utils';\n\ntype ParsedAutorotatePluginConfig = Omit<\n    AutorotatePluginConfig,\n    | 'autorotateSpeed'\n    | 'autorotatePitch'\n> & {\n    autorotateSpeed?: number;\n    autorotatePitch?: number;\n};\n\ntype AutorotateKeypointInternal = {\n    position: [number, number];\n    markerId: string;\n    pause: number;\n    tooltip: { content: string; position?: string };\n};\n\nconst getConfig = utils.getConfigParser<AutorotatePluginConfig, ParsedAutorotatePluginConfig>(\n    {\n        autostartDelay: 2000,\n        autostartOnIdle: true,\n        autorotateSpeed: utils.parseSpeed('2rpm'),\n        autorotatePitch: null,\n        autorotateZoomLvl: null,\n        keypoints: null,\n        startFromClosest: true,\n    },\n    {\n        autostartOnIdle: (autostartOnIdle, { rawConfig }) => {\n            if (autostartOnIdle && utils.isNil(rawConfig.autostartDelay)) {\n                utils.logWarn('autostartOnIdle requires a non null autostartDelay');\n                return false;\n            }\n            return autostartOnIdle;\n        },\n        autorotateSpeed: (autorotateSpeed) => {\n            return utils.parseSpeed(autorotateSpeed);\n        },\n        autorotatePitch: (autorotatePitch) => {\n            // autorotatePitch is between -PI/2 and PI/2\n            if (!utils.isNil(autorotatePitch)) {\n                return utils.parseAngle(autorotatePitch, true);\n            }\n            return null;\n        },\n        autorotateZoomLvl: (autorotateZoomLvl) => {\n            if (!utils.isNil(autorotateZoomLvl)) {\n                return MathUtils.clamp(autorotateZoomLvl, 0, 100);\n            }\n            return null;\n        },\n    }\n);\n\nconst NUM_STEPS = 16;\n\nfunction serializePt(position: Position): [number, number] {\n    return [position.yaw, position.pitch];\n}\n\n/**\n * Adds an automatic rotation of the panorama\n */\nexport class AutorotatePlugin extends AbstractConfigurablePlugin<\n    AutorotatePluginConfig,\n    ParsedAutorotatePluginConfig,\n    UpdatableAutorotatePluginConfig,\n    AutorotatePluginEvents\n> {\n    static override readonly id = 'autorotate';\n    static override readonly configParser = getConfig;\n    static override readonly readonlyOptions: Array<keyof AutorotatePluginConfig> = ['keypoints'];\n\n    private readonly state = {\n        initialStart: true,\n        /** if the automatic rotation is enabled */\n        enabled: false,\n        /** current index in keypoints */\n        idx: -1,\n        /** curve between idx and idx + 1 */\n        curve: [] as [number, number][],\n        /** start point of the current step */\n        startStep: null as [number, number],\n        /** end point of the current step */\n        endStep: null as [number, number],\n        /** start time of the current step  */\n        startTime: null as number,\n        /** expected duration of the step */\n        stepDuration: null as number,\n        /** time remaining for the pause */\n        remainingPause: null as number,\n        /** previous timestamp in render loop */\n        lastTime: null as number,\n        /** currently displayed tooltip */\n        tooltip: null as Tooltip,\n    };\n\n    private keypoints: AutorotateKeypointInternal[];\n\n    private video?: VideoPlugin;\n    private markers?: MarkersPlugin;\n\n    constructor(viewer: Viewer, config: AutorotatePluginConfig) {\n        super(viewer, config);\n\n        this.state.initialStart = !utils.isNil(this.config.autostartDelay);\n    }\n\n    /**\n     * @internal\n     */\n    override init() {\n        super.init();\n\n        this.video = this.viewer.getPlugin('video');\n        this.markers = this.viewer.getPlugin('markers');\n\n        if (this.config.keypoints) {\n            this.setKeypoints(this.config.keypoints);\n            delete this.config.keypoints;\n        }\n\n        this.viewer.addEventListener(events.StopAllEvent.type, this);\n        this.viewer.addEventListener(events.BeforeRenderEvent.type, this);\n\n        // conflict with play/pause of the video plugin\n        if (!this.video) {\n            this.viewer.addEventListener(events.KeypressEvent.type, this);\n        }\n    }\n\n    /**\n     * @internal\n     */\n    override destroy() {\n        this.viewer.removeEventListener(events.StopAllEvent.type, this);\n        this.viewer.removeEventListener(events.BeforeRenderEvent.type, this);\n        this.viewer.removeEventListener(events.KeypressEvent.type, this);\n\n        delete this.video;\n        delete this.markers;\n        delete this.keypoints;\n\n        super.destroy();\n    }\n\n    /**\n     * @internal\n     */\n    handleEvent(e: Event) {\n        switch (e.type) {\n            case events.StopAllEvent.type:\n                this.stop();\n                break;\n\n            case events.BeforeRenderEvent.type: {\n                this.__beforeRender((e as events.BeforeRenderEvent).timestamp);\n                break;\n            }\n\n            case events.KeypressEvent.type:\n                if ((e as events.KeypressEvent).key === CONSTANTS.KEY_CODES.Space && this.viewer.state.keyboardEnabled) {\n                    this.toggle();\n                    e.preventDefault();\n                }\n                break;\n        }\n    }\n\n    /**\n     * Changes the keypoints\n     * @throws {@link PSVError} if the configuration is invalid\n     */\n    setKeypoints(keypoints: AutorotateKeypoint[]) {\n        if (!keypoints) {\n            this.keypoints = null;\n        } else {\n            if (keypoints.length < 2) {\n                throw new PSVError('At least two points are required');\n            }\n\n            this.keypoints = keypoints.map((pt, i) => {\n                const keypoint: AutorotateKeypointInternal = {\n                    position: null,\n                    markerId: null,\n                    pause: 0,\n                    tooltip: null,\n                };\n\n                let position: ExtendedPosition;\n\n                if (typeof pt === 'string') {\n                    keypoint.markerId = pt;\n                } else if (utils.isExtendedPosition(pt)) {\n                    position = pt;\n                } else {\n                    keypoint.markerId = pt.markerId;\n                    keypoint.pause = pt.pause;\n                    position = pt.position;\n\n                    if (pt.tooltip && typeof pt.tooltip === 'object') {\n                        keypoint.tooltip = pt.tooltip;\n                    } else if (typeof pt.tooltip === 'string') {\n                        keypoint.tooltip = { content: pt.tooltip };\n                    }\n                }\n\n                if (keypoint.markerId) {\n                    if (!this.markers) {\n                        throw new PSVError(`Keypoint #${i} references a marker but the markers plugin is not loaded`);\n                    }\n                    const marker = this.markers.getMarker(keypoint.markerId);\n                    keypoint.position = serializePt(marker.state.position);\n                } else if (position) {\n                    keypoint.position = serializePt(this.viewer.dataHelper.cleanPosition(position));\n                } else {\n                    throw new PSVError(`Keypoint #${i} is missing marker or position`);\n                }\n\n                return keypoint;\n            });\n        }\n\n        if (this.isEnabled()) {\n            this.stop();\n            this.start();\n        }\n    }\n\n    /**\n     * Checks if the automatic rotation is enabled\n     */\n    isEnabled(): boolean {\n        return this.state.enabled;\n    }\n\n    /**\n     * Starts the automatic rotation\n     */\n    start() {\n        if (this.isEnabled()) {\n            return;\n        }\n\n        this.viewer.stopAll();\n\n        if (!this.keypoints) {\n            this.__animate();\n        } else if (this.config.startFromClosest) {\n            this.__shiftKeypoints();\n        }\n\n        this.state.initialStart = false;\n        this.state.enabled = true;\n\n        this.dispatchEvent(new AutorotateEvent(true));\n    }\n\n    /**\n     * Stops the automatic rotation\n     */\n    stop() {\n        if (!this.isEnabled()) {\n            return;\n        }\n\n        this.__reset();\n        this.__hideTooltip();\n\n        this.viewer.dynamics.position.stop();\n        this.viewer.dynamics.zoom.stop();\n\n        this.state.enabled = false;\n\n        this.dispatchEvent(new AutorotateEvent(false));\n    }\n\n    /**\n     * Starts or stops the automatic rotation\n     */\n    toggle() {\n        if (this.isEnabled()) {\n            this.stop();\n        } else {\n            this.start();\n        }\n    }\n\n    /**\n     * @internal\n     */\n    reverse() {\n        if (this.isEnabled() && !this.keypoints) {\n            this.config.autorotateSpeed = -this.config.autorotateSpeed;\n            this.__animate();\n        }\n    }\n\n    /**\n     * Launches the standard animation\n     */\n    private __animate() {\n        // do the zoom before the rotation\n        let p: PromiseLike<any>;\n        if (!utils.isNil(this.config.autorotateZoomLvl)) {\n            p = this.viewer.animate({\n                zoom: this.config.autorotateZoomLvl,\n                // \"2\" is magic, and kinda related to the \"PI/4\" in animate()\n                speed: `${this.viewer.config.zoomSpeed * 2}rpm`,\n            });\n        } else {\n            p = Promise.resolve();\n        }\n\n        p.then(() => {\n            this.viewer.dynamics.position.roll(\n                {\n                    yaw: this.config.autorotateSpeed < 0,\n                },\n                Math.abs(this.config.autorotateSpeed / this.viewer.config.moveSpeed)\n            );\n\n            this.viewer.dynamics.position.goto(\n                {\n                    pitch: this.config.autorotatePitch ?? this.viewer.config.defaultPitch,\n                },\n                Math.abs(this.config.autorotateSpeed / this.viewer.config.moveSpeed)\n            );\n        });\n    }\n\n    /**\n     * Resets all the curve variables\n     */\n    private __reset() {\n        this.state.idx = -1;\n        this.state.curve = [];\n        this.state.startStep = null;\n        this.state.endStep = null;\n        this.state.startTime = null;\n        this.state.stepDuration = null;\n        this.state.remainingPause = null;\n        this.state.lastTime = null;\n        this.state.tooltip = null;\n    }\n\n    /**\n     * Automatically starts if the delay is reached\n     * Performs keypoints animation\n     */\n    private __beforeRender(timestamp: number) {\n        if (\n            (this.state.initialStart || this.config.autostartOnIdle)\n            && this.viewer.state.idleTime > 0\n            && timestamp - this.viewer.state.idleTime > this.config.autostartDelay\n        ) {\n            this.start();\n        }\n\n        if (this.isEnabled() && this.keypoints) {\n            // initialisation\n            if (!this.state.startTime) {\n                this.state.endStep = serializePt(this.viewer.getPosition());\n                this.__nextStep();\n\n                this.state.startTime = timestamp;\n                this.state.lastTime = timestamp;\n            }\n\n            this.__nextFrame(timestamp);\n        }\n    }\n\n    private __shiftKeypoints() {\n        const currentPosition = serializePt(this.viewer.getPosition());\n        const index = this.__findMinIndex(this.keypoints, (keypoint) => {\n            return utils.greatArcDistance(keypoint.position, currentPosition);\n        });\n\n        this.keypoints.push(...this.keypoints.splice(0, index));\n    }\n\n    private __incrementIdx() {\n        this.state.idx++;\n        if (this.state.idx === this.keypoints.length) {\n            this.state.idx = 0;\n        }\n    }\n\n    private __showTooltip() {\n        const keypoint = this.keypoints[this.state.idx];\n\n        if (keypoint.tooltip) {\n            const position = this.viewer.dataHelper.vector3ToViewerCoords(this.viewer.state.direction);\n\n            this.state.tooltip = this.viewer.createTooltip({\n                content: keypoint.tooltip.content,\n                position: keypoint.tooltip.position,\n                top: position.y,\n                left: position.x,\n            });\n        } else if (keypoint.markerId) {\n            const marker = this.markers.getMarker(keypoint.markerId);\n            marker.showTooltip();\n            this.state.tooltip = marker.tooltip;\n        }\n    }\n\n    private __hideTooltip() {\n        if (this.state.tooltip) {\n            const keypoint = this.keypoints[this.state.idx];\n\n            if (keypoint.tooltip) {\n                this.state.tooltip.hide();\n            } else if (keypoint.markerId) {\n                const marker = this.markers.getMarker(keypoint.markerId);\n                marker.hideTooltip();\n            }\n\n            this.state.tooltip = null;\n        }\n    }\n\n    private __nextPoint() {\n        // get the 4 points necessary to compute the current movement\n        // the two points of the current segments and one point before and after\n        const workPoints = [];\n        if (this.state.idx === -1) {\n            const currentPosition = serializePt(this.viewer.getPosition());\n            // prettier-ignore\n            workPoints.push(\n                currentPosition,\n                currentPosition,\n                this.keypoints[0].position,\n                this.keypoints[1].position\n            );\n        } else {\n            for (let i = -1; i < 3; i++) {\n                const keypoint =\n                    this.state.idx + i < 0\n                        ? this.keypoints[this.keypoints.length - 1]\n                        : this.keypoints[(this.state.idx + i) % this.keypoints.length];\n                workPoints.push(keypoint.position);\n            }\n        }\n\n        // apply offsets to avoid crossing the origin\n        const workVectors = [new Vector2(workPoints[0][0], workPoints[0][1])];\n\n        let k = 0;\n        for (let i = 1; i <= 3; i++) {\n            const d = workPoints[i - 1][0] - workPoints[i][0];\n            if (d > Math.PI) {\n                // crossed the origin left to right\n                k += 1;\n            } else if (d < -Math.PI) {\n                // crossed the origin right to left\n                k -= 1;\n            }\n            if (k !== 0 && i === 1) {\n                // do not modify first point, apply the reverse offset the the previous point instead\n                workVectors[0].x -= k * 2 * Math.PI;\n                k = 0;\n            }\n            workVectors.push(new Vector2(workPoints[i][0] + k * 2 * Math.PI, workPoints[i][1]));\n        }\n\n        const curve: [number, number][] = new SplineCurve(workVectors).getPoints(NUM_STEPS * 3).map((p) => [p.x, p.y]);\n\n        // debugCurve(this.markers, curve, NUM_STEPS);\n\n        // only keep the curve for the current movement\n        this.state.curve = curve.slice(NUM_STEPS + 1, NUM_STEPS * 2 + 1);\n\n        if (this.state.idx !== -1) {\n            this.state.remainingPause = this.keypoints[this.state.idx].pause;\n\n            if (this.state.remainingPause) {\n                this.__showTooltip();\n            } else {\n                this.__incrementIdx();\n            }\n        } else {\n            this.__incrementIdx();\n        }\n    }\n\n    private __nextStep() {\n        if (this.state.curve.length === 0) {\n            this.__nextPoint();\n\n            // reset transformation made to the previous point\n            this.state.endStep[0] = utils.parseAngle(this.state.endStep[0]);\n        }\n\n        // target next point\n        this.state.startStep = this.state.endStep;\n        this.state.endStep = this.state.curve.shift();\n\n        // compute duration from distance and speed\n        const distance = utils.greatArcDistance(this.state.startStep, this.state.endStep);\n        this.state.stepDuration = (distance * 1000) / Math.abs(this.config.autorotateSpeed);\n\n        if (distance === 0) {\n            // edge case\n            this.__nextStep();\n        }\n    }\n\n    private __nextFrame(timestamp: number) {\n        const ellapsed = timestamp - this.state.lastTime;\n        this.state.lastTime = timestamp;\n\n        // currently paused\n        if (this.state.remainingPause) {\n            this.state.remainingPause = Math.max(0, this.state.remainingPause - ellapsed);\n            if (this.state.remainingPause > 0) {\n                return;\n            } else {\n                this.__hideTooltip();\n                this.__incrementIdx();\n                this.state.startTime = timestamp;\n            }\n        }\n\n        let progress = (timestamp - this.state.startTime) / this.state.stepDuration;\n        if (progress >= 1) {\n            this.__nextStep();\n            progress = 0;\n            this.state.startTime = timestamp;\n        }\n\n        this.viewer.rotate({\n            yaw: this.state.startStep[0] + (this.state.endStep[0] - this.state.startStep[0]) * progress,\n            pitch: this.state.startStep[1] + (this.state.endStep[1] - this.state.startStep[1]) * progress,\n        });\n    }\n\n    private __findMinIndex<T>(array: T[], mapper: (item: T) => number) {\n        let idx = 0;\n        let current = Number.MAX_VALUE;\n\n        array.forEach((item, i) => {\n            const value = mapper(item);\n            if (value < current) {\n                current = value;\n                idx = i;\n            }\n        });\n\n        return idx;\n    }\n}\n"],"mappings":"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","names":[]}