{"version":3,"sources":["@photo-sphere-viewer/core","three","src/index.ts","src/CubemapAdapter.ts","src/utils.ts"],"sourcesContent":["module.exports = PhotoSphereViewer","module.exports = THREE","export { CubemapAdapter } from './CubemapAdapter';\nexport * from './model';\n","import type { TextureData, Viewer } from '@photo-sphere-viewer/core';\nimport { AbstractAdapter, CONSTANTS, PSVError, SYSTEM, utils } from '@photo-sphere-viewer/core';\nimport { BoxGeometry, Mesh, ShaderMaterial, Texture } from 'three';\nimport {\n    Cubemap,\n    CubemapAdapterConfig,\n    CubemapFaces,\n    CubemapNet,\n    CubemapPanorama,\n    CubemapSeparate,\n    CubemapStripe,\n} from './model';\nimport { cleanCubemap, cleanCubemapArray, isCubemap } from './utils';\n\ntype CubemapMesh = Mesh<BoxGeometry, ShaderMaterial[]>;\ntype CubemapTexture = TextureData<Texture[], CubemapPanorama>;\n\nconst getConfig = utils.getConfigParser<CubemapAdapterConfig>({\n    flipTopBottom: false,\n    blur: false,\n});\n\n/**\n * Adapter for cubemaps\n */\nexport class CubemapAdapter extends AbstractAdapter<CubemapPanorama, Texture[]> {\n    static override readonly id = 'cubemap';\n    static override readonly supportsDownload = false;\n    static override readonly supportsOverlay = true;\n\n    private readonly config: CubemapAdapterConfig;\n\n    constructor(viewer: Viewer, config: CubemapAdapterConfig) {\n        super(viewer);\n\n        this.config = getConfig(config);\n    }\n\n    override supportsTransition() {\n        return true;\n    }\n\n    override supportsPreload() {\n        return true;\n    }\n\n    async loadTexture(panorama: CubemapPanorama): Promise<CubemapTexture> {\n        if (this.viewer.config.fisheye) {\n            utils.logWarn('fisheye effect with cubemap texture can generate distorsion');\n        }\n\n        let cleanPanorama: CubemapSeparate | CubemapStripe | CubemapNet;\n        if (Array.isArray(panorama) || isCubemap(panorama)) {\n            cleanPanorama = {\n                type: 'separate',\n                paths: panorama,\n            } as CubemapSeparate;\n        } else {\n            cleanPanorama = panorama as any;\n        }\n\n        let texture: Texture[];\n        switch (cleanPanorama.type) {\n            case 'separate': {\n                let paths: string[];\n                if (Array.isArray(cleanPanorama.paths)) {\n                    paths = cleanCubemapArray(cleanPanorama.paths as string[]);\n                } else {\n                    paths = cleanCubemap(cleanPanorama.paths as Cubemap);\n                }\n\n                texture = await this.loadTexturesSeparate(paths);\n                break;\n            }\n\n            case 'stripe':\n                texture = await this.loadTexturesStripe(cleanPanorama.path, cleanPanorama.order);\n                break;\n\n            case 'net':\n                texture = await this.loadTexturesNet(cleanPanorama.path);\n                break;\n\n            default:\n                throw new PSVError('Invalid cubemap panorama, are you using the right adapter?');\n        }\n\n        return { panorama, texture };\n    }\n\n    private loadTexturesSeparate(paths: string[]): Promise<Texture[]> {\n        const promises: Promise<Texture>[] = [];\n        const progress = [0, 0, 0, 0, 0, 0];\n\n        for (let i = 0; i < 6; i++) {\n            promises.push(\n                this.viewer.textureLoader\n                    .loadImage(paths[i], (p) => {\n                        progress[i] = p;\n                        this.viewer.loader.setProgress(utils.sum(progress) / 6);\n                    })\n                    .then((img) => this.createCubemapTexture(img))\n            );\n        }\n\n        return Promise.all(promises);\n    }\n\n    private createCubemapTexture(img: HTMLImageElement): Texture {\n        if (img.width !== img.height) {\n            utils.logWarn('Invalid cubemap image, the width should equal the height');\n        }\n\n        // resize image\n        if (this.config.blur || img.width > SYSTEM.maxTextureWidth) {\n            const ratio = Math.min(1, SYSTEM.maxCanvasWidth / img.width);\n\n            const buffer = document.createElement('canvas');\n            buffer.width = img.width * ratio;\n            buffer.height = img.height * ratio;\n\n            const ctx = buffer.getContext('2d');\n\n            if (this.config.blur) {\n                ctx.filter = `blur(${buffer.width / 512}px)`;\n            }\n\n            ctx.drawImage(img, 0, 0, buffer.width, buffer.height);\n\n            return utils.createTexture(buffer);\n        }\n\n        return utils.createTexture(img);\n    }\n\n    private async loadTexturesStripe(\n        path: string,\n        order: CubemapStripe['order'] = ['left', 'front', 'right', 'back', 'top', 'bottom']\n    ): Promise<Texture[]> {\n        const img = await this.viewer.textureLoader.loadImage(path, (p) => this.viewer.loader.setProgress(p));\n\n        if (img.width !== img.height * 6) {\n            utils.logWarn('Invalid cubemap image, the width should be six times the height');\n        }\n\n        const ratio = Math.min(1, SYSTEM.maxCanvasWidth / img.height);\n        const tileWidth = img.height * ratio;\n\n        const textures = {} as { [K in CubemapFaces]: Texture };\n\n        for (let i = 0; i < 6; i++) {\n            const buffer = document.createElement('canvas');\n            buffer.width = tileWidth;\n            buffer.height = tileWidth;\n\n            const ctx = buffer.getContext('2d');\n\n            if (this.config.blur) {\n                ctx.filter = 'blur(1px)';\n            }\n\n            ctx.drawImage(\n                img,\n                img.height * i, 0,\n                img.height, img.height,\n                0, 0,\n                tileWidth, tileWidth\n            );\n\n            textures[order[i]] = utils.createTexture(buffer);\n        }\n\n        return cleanCubemap(textures);\n    }\n\n    private async loadTexturesNet(path: string): Promise<Texture[]> {\n        const img = await this.viewer.textureLoader.loadImage(path, (p) => this.viewer.loader.setProgress(p));\n\n        if (img.width / 4 !== img.height / 3) {\n            utils.logWarn('Invalid cubemap image, the width should be 4/3rd of the height');\n        }\n\n        const ratio = Math.min(1, SYSTEM.maxCanvasWidth / (img.width / 4));\n        const tileWidth = (img.width / 4) * ratio;\n\n        const pts = [\n            [0, 1 / 3], // left\n            [1 / 2, 1 / 3], // right\n            [1 / 4, 0], // top\n            [1 / 4, 2 / 3], // bottom\n            [3 / 4, 1 / 3], // back\n            [1 / 4, 1 / 3], // front\n        ];\n\n        const textures: Texture[] = [];\n\n        for (let i = 0; i < 6; i++) {\n            const buffer = document.createElement('canvas');\n            buffer.width = tileWidth;\n            buffer.height = tileWidth;\n\n            const ctx = buffer.getContext('2d');\n\n            if (this.config.blur) {\n                ctx.filter = 'blur(1px)';\n            }\n\n            ctx.drawImage(\n                img,\n                img.width * pts[i][0], img.height * pts[i][1],\n                img.width / 4, img.height / 3,\n                0, 0,\n                tileWidth, tileWidth\n            );\n\n            textures[i] = utils.createTexture(buffer);\n        }\n\n        return textures;\n    }\n\n    createMesh(scale = 1): CubemapMesh {\n        const cubeSize = CONSTANTS.SPHERE_RADIUS * 2 * scale;\n        const geometry = new BoxGeometry(cubeSize, cubeSize, cubeSize).scale(1, 1, -1) as BoxGeometry;\n\n        const materials = [];\n        for (let i = 0; i < 6; i++) {\n            materials.push(\n                AbstractAdapter.createOverlayMaterial({\n                    additionalUniforms: {\n                        rotation: { value: 0.0 },\n                    },\n                    overrideVertexShader: `\nuniform float rotation;\nvarying vec2 vUv;\nconst float mid = 0.5;\nvoid main() {\n  if (rotation == 0.0) {\n    vUv = uv;\n  } else {\n    vUv = vec2(\n      cos(rotation) * (uv.x - mid) + sin(rotation) * (uv.y - mid) + mid,\n      cos(rotation) * (uv.y - mid) - sin(rotation) * (uv.x - mid) + mid\n    );\n  }\n  gl_Position = projectionMatrix *  modelViewMatrix * vec4( position, 1.0 );\n}`,\n                })\n            );\n        }\n\n        return new Mesh(geometry, materials);\n    }\n\n    setTexture(mesh: CubemapMesh, textureData: CubemapTexture) {\n        const { texture, panorama } = textureData;\n        const isNet = (panorama as CubemapNet).type === 'net';\n        const flipTopBottom = isNet ? !this.config.flipTopBottom : this.config.flipTopBottom;\n\n        for (let i = 0; i < 6; i++) {\n            if (flipTopBottom && (i === 2 || i === 3)) {\n                this.__setUniform(mesh, i, 'rotation', Math.PI);\n            }\n\n            this.__setUniform(mesh, i, AbstractAdapter.OVERLAY_UNIFORMS.panorama, texture[i]);\n        }\n\n        this.setOverlay(mesh, null, 0);\n    }\n\n    setOverlay(mesh: CubemapMesh, textureData: CubemapTexture, opacity: number) {\n        for (let i = 0; i < 6; i++) {\n            this.__setUniform(mesh, i, AbstractAdapter.OVERLAY_UNIFORMS.overlayOpacity, opacity);\n            if (!textureData) {\n                this.__setUniform(mesh, i, AbstractAdapter.OVERLAY_UNIFORMS.overlay, new Texture());\n            } else {\n                this.__setUniform(mesh, i, AbstractAdapter.OVERLAY_UNIFORMS.overlay, textureData.texture[i]);\n            }\n        }\n    }\n\n    setTextureOpacity(mesh: CubemapMesh, opacity: number) {\n        for (let i = 0; i < 6; i++) {\n            this.__setUniform(mesh, i, AbstractAdapter.OVERLAY_UNIFORMS.globalOpacity, opacity);\n            mesh.material[i].transparent = opacity < 1;\n        }\n    }\n\n    disposeTexture(textureData: CubemapTexture) {\n        textureData.texture?.forEach((texture) => texture.dispose());\n    }\n\n    private __setUniform(mesh: CubemapMesh, index: number, uniform: string, value: any) {\n        if (mesh.material[index].uniforms[uniform].value instanceof Texture) {\n            mesh.material[index].uniforms[uniform].value.dispose();\n        }\n        mesh.material[index].uniforms[uniform].value = value;\n    }\n}\n","import { PSVError } from '@photo-sphere-viewer/core';\nimport { Cubemap, CubemapFaces } from './model';\n\n// PSV faces order is left, front, right, back, top, bottom\n// 3JS faces order is left, right, top, bottom, back, front\nconst CUBE_ARRAY = [0, 2, 4, 5, 3, 1];\nconst CUBE_HASHMAP: CubemapFaces[] = ['left', 'right', 'top', 'bottom', 'back', 'front'];\n\nexport function isCubemap(cubemap: any): cubemap is Cubemap {\n    return cubemap && typeof cubemap === 'object' && CUBE_HASHMAP.every((side) => side in cubemap);\n}\n\n/**\n * Given an array of 6 objects in PSV order, returns an array in 3JS order\n */\nexport function cleanCubemapArray<T>(panorama: T[]): T[] {\n    const cleanPanorama: T[] = [];\n\n    if (panorama.length !== 6) {\n        throw new PSVError('A cubemap array must contain exactly 6 images.');\n    }\n\n    // reorder images\n    for (let i = 0; i < 6; i++) {\n        cleanPanorama[i] = panorama[CUBE_ARRAY[i]];\n    }\n\n    return cleanPanorama;\n}\n\n/**\n * Given an object where keys are faces names, retusn an array in 3JS order\n */\nexport function cleanCubemap<T>(cubemap: { [K in CubemapFaces]: T }): T[] {\n    const cleanPanorama: T[] = [];\n\n    if (!isCubemap(cubemap)) {\n        throw new PSVError('A cubemap object must contain exactly left, front, right, back, top, bottom images.');\n    }\n\n    // transform into array\n    CUBE_HASHMAP.forEach((side, i) => {\n        cleanPanorama[i] = (cubemap as any)[side];\n    });\n\n    return cleanPanorama;\n}\n"],"mappings":"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","names":["import_core"]}