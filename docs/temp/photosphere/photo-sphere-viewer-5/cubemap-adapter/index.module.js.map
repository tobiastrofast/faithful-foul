{"version":3,"sources":["../src/CubemapAdapter.ts","../src/utils.ts"],"sourcesContent":["import type { TextureData, Viewer } from '@photo-sphere-viewer/core';\nimport { AbstractAdapter, CONSTANTS, PSVError, SYSTEM, utils } from '@photo-sphere-viewer/core';\nimport { BoxGeometry, Mesh, ShaderMaterial, Texture } from 'three';\nimport {\n    Cubemap,\n    CubemapAdapterConfig,\n    CubemapFaces,\n    CubemapNet,\n    CubemapPanorama,\n    CubemapSeparate,\n    CubemapStripe,\n} from './model';\nimport { cleanCubemap, cleanCubemapArray, isCubemap } from './utils';\n\ntype CubemapMesh = Mesh<BoxGeometry, ShaderMaterial[]>;\ntype CubemapTexture = TextureData<Texture[], CubemapPanorama>;\n\nconst getConfig = utils.getConfigParser<CubemapAdapterConfig>({\n    flipTopBottom: false,\n    blur: false,\n});\n\n/**\n * Adapter for cubemaps\n */\nexport class CubemapAdapter extends AbstractAdapter<CubemapPanorama, Texture[]> {\n    static override readonly id = 'cubemap';\n    static override readonly supportsDownload = false;\n    static override readonly supportsOverlay = true;\n\n    private readonly config: CubemapAdapterConfig;\n\n    constructor(viewer: Viewer, config: CubemapAdapterConfig) {\n        super(viewer);\n\n        this.config = getConfig(config);\n    }\n\n    override supportsTransition() {\n        return true;\n    }\n\n    override supportsPreload() {\n        return true;\n    }\n\n    async loadTexture(panorama: CubemapPanorama): Promise<CubemapTexture> {\n        if (this.viewer.config.fisheye) {\n            utils.logWarn('fisheye effect with cubemap texture can generate distorsion');\n        }\n\n        let cleanPanorama: CubemapSeparate | CubemapStripe | CubemapNet;\n        if (Array.isArray(panorama) || isCubemap(panorama)) {\n            cleanPanorama = {\n                type: 'separate',\n                paths: panorama,\n            } as CubemapSeparate;\n        } else {\n            cleanPanorama = panorama as any;\n        }\n\n        let texture: Texture[];\n        switch (cleanPanorama.type) {\n            case 'separate': {\n                let paths: string[];\n                if (Array.isArray(cleanPanorama.paths)) {\n                    paths = cleanCubemapArray(cleanPanorama.paths as string[]);\n                } else {\n                    paths = cleanCubemap(cleanPanorama.paths as Cubemap);\n                }\n\n                texture = await this.loadTexturesSeparate(paths);\n                break;\n            }\n\n            case 'stripe':\n                texture = await this.loadTexturesStripe(cleanPanorama.path, cleanPanorama.order);\n                break;\n\n            case 'net':\n                texture = await this.loadTexturesNet(cleanPanorama.path);\n                break;\n\n            default:\n                throw new PSVError('Invalid cubemap panorama, are you using the right adapter?');\n        }\n\n        return { panorama, texture };\n    }\n\n    private loadTexturesSeparate(paths: string[]): Promise<Texture[]> {\n        const promises: Promise<Texture>[] = [];\n        const progress = [0, 0, 0, 0, 0, 0];\n\n        for (let i = 0; i < 6; i++) {\n            promises.push(\n                this.viewer.textureLoader\n                    .loadImage(paths[i], (p) => {\n                        progress[i] = p;\n                        this.viewer.loader.setProgress(utils.sum(progress) / 6);\n                    })\n                    .then((img) => this.createCubemapTexture(img))\n            );\n        }\n\n        return Promise.all(promises);\n    }\n\n    private createCubemapTexture(img: HTMLImageElement): Texture {\n        if (img.width !== img.height) {\n            utils.logWarn('Invalid cubemap image, the width should equal the height');\n        }\n\n        // resize image\n        if (this.config.blur || img.width > SYSTEM.maxTextureWidth) {\n            const ratio = Math.min(1, SYSTEM.maxCanvasWidth / img.width);\n\n            const buffer = document.createElement('canvas');\n            buffer.width = img.width * ratio;\n            buffer.height = img.height * ratio;\n\n            const ctx = buffer.getContext('2d');\n\n            if (this.config.blur) {\n                ctx.filter = `blur(${buffer.width / 512}px)`;\n            }\n\n            ctx.drawImage(img, 0, 0, buffer.width, buffer.height);\n\n            return utils.createTexture(buffer);\n        }\n\n        return utils.createTexture(img);\n    }\n\n    private async loadTexturesStripe(\n        path: string,\n        order: CubemapStripe['order'] = ['left', 'front', 'right', 'back', 'top', 'bottom']\n    ): Promise<Texture[]> {\n        const img = await this.viewer.textureLoader.loadImage(path, (p) => this.viewer.loader.setProgress(p));\n\n        if (img.width !== img.height * 6) {\n            utils.logWarn('Invalid cubemap image, the width should be six times the height');\n        }\n\n        const ratio = Math.min(1, SYSTEM.maxCanvasWidth / img.height);\n        const tileWidth = img.height * ratio;\n\n        const textures = {} as { [K in CubemapFaces]: Texture };\n\n        for (let i = 0; i < 6; i++) {\n            const buffer = document.createElement('canvas');\n            buffer.width = tileWidth;\n            buffer.height = tileWidth;\n\n            const ctx = buffer.getContext('2d');\n\n            if (this.config.blur) {\n                ctx.filter = 'blur(1px)';\n            }\n\n            ctx.drawImage(\n                img,\n                img.height * i, 0,\n                img.height, img.height,\n                0, 0,\n                tileWidth, tileWidth\n            );\n\n            textures[order[i]] = utils.createTexture(buffer);\n        }\n\n        return cleanCubemap(textures);\n    }\n\n    private async loadTexturesNet(path: string): Promise<Texture[]> {\n        const img = await this.viewer.textureLoader.loadImage(path, (p) => this.viewer.loader.setProgress(p));\n\n        if (img.width / 4 !== img.height / 3) {\n            utils.logWarn('Invalid cubemap image, the width should be 4/3rd of the height');\n        }\n\n        const ratio = Math.min(1, SYSTEM.maxCanvasWidth / (img.width / 4));\n        const tileWidth = (img.width / 4) * ratio;\n\n        const pts = [\n            [0, 1 / 3], // left\n            [1 / 2, 1 / 3], // right\n            [1 / 4, 0], // top\n            [1 / 4, 2 / 3], // bottom\n            [3 / 4, 1 / 3], // back\n            [1 / 4, 1 / 3], // front\n        ];\n\n        const textures: Texture[] = [];\n\n        for (let i = 0; i < 6; i++) {\n            const buffer = document.createElement('canvas');\n            buffer.width = tileWidth;\n            buffer.height = tileWidth;\n\n            const ctx = buffer.getContext('2d');\n\n            if (this.config.blur) {\n                ctx.filter = 'blur(1px)';\n            }\n\n            ctx.drawImage(\n                img,\n                img.width * pts[i][0], img.height * pts[i][1],\n                img.width / 4, img.height / 3,\n                0, 0,\n                tileWidth, tileWidth\n            );\n\n            textures[i] = utils.createTexture(buffer);\n        }\n\n        return textures;\n    }\n\n    createMesh(scale = 1): CubemapMesh {\n        const cubeSize = CONSTANTS.SPHERE_RADIUS * 2 * scale;\n        const geometry = new BoxGeometry(cubeSize, cubeSize, cubeSize).scale(1, 1, -1) as BoxGeometry;\n\n        const materials = [];\n        for (let i = 0; i < 6; i++) {\n            materials.push(\n                AbstractAdapter.createOverlayMaterial({\n                    additionalUniforms: {\n                        rotation: { value: 0.0 },\n                    },\n                    overrideVertexShader: `\nuniform float rotation;\nvarying vec2 vUv;\nconst float mid = 0.5;\nvoid main() {\n  if (rotation == 0.0) {\n    vUv = uv;\n  } else {\n    vUv = vec2(\n      cos(rotation) * (uv.x - mid) + sin(rotation) * (uv.y - mid) + mid,\n      cos(rotation) * (uv.y - mid) - sin(rotation) * (uv.x - mid) + mid\n    );\n  }\n  gl_Position = projectionMatrix *  modelViewMatrix * vec4( position, 1.0 );\n}`,\n                })\n            );\n        }\n\n        return new Mesh(geometry, materials);\n    }\n\n    setTexture(mesh: CubemapMesh, textureData: CubemapTexture) {\n        const { texture, panorama } = textureData;\n        const isNet = (panorama as CubemapNet).type === 'net';\n        const flipTopBottom = isNet ? !this.config.flipTopBottom : this.config.flipTopBottom;\n\n        for (let i = 0; i < 6; i++) {\n            if (flipTopBottom && (i === 2 || i === 3)) {\n                this.__setUniform(mesh, i, 'rotation', Math.PI);\n            }\n\n            this.__setUniform(mesh, i, AbstractAdapter.OVERLAY_UNIFORMS.panorama, texture[i]);\n        }\n\n        this.setOverlay(mesh, null, 0);\n    }\n\n    setOverlay(mesh: CubemapMesh, textureData: CubemapTexture, opacity: number) {\n        for (let i = 0; i < 6; i++) {\n            this.__setUniform(mesh, i, AbstractAdapter.OVERLAY_UNIFORMS.overlayOpacity, opacity);\n            if (!textureData) {\n                this.__setUniform(mesh, i, AbstractAdapter.OVERLAY_UNIFORMS.overlay, new Texture());\n            } else {\n                this.__setUniform(mesh, i, AbstractAdapter.OVERLAY_UNIFORMS.overlay, textureData.texture[i]);\n            }\n        }\n    }\n\n    setTextureOpacity(mesh: CubemapMesh, opacity: number) {\n        for (let i = 0; i < 6; i++) {\n            this.__setUniform(mesh, i, AbstractAdapter.OVERLAY_UNIFORMS.globalOpacity, opacity);\n            mesh.material[i].transparent = opacity < 1;\n        }\n    }\n\n    disposeTexture(textureData: CubemapTexture) {\n        textureData.texture?.forEach((texture) => texture.dispose());\n    }\n\n    private __setUniform(mesh: CubemapMesh, index: number, uniform: string, value: any) {\n        if (mesh.material[index].uniforms[uniform].value instanceof Texture) {\n            mesh.material[index].uniforms[uniform].value.dispose();\n        }\n        mesh.material[index].uniforms[uniform].value = value;\n    }\n}\n","import { PSVError } from '@photo-sphere-viewer/core';\nimport { Cubemap, CubemapFaces } from './model';\n\n// PSV faces order is left, front, right, back, top, bottom\n// 3JS faces order is left, right, top, bottom, back, front\nconst CUBE_ARRAY = [0, 2, 4, 5, 3, 1];\nconst CUBE_HASHMAP: CubemapFaces[] = ['left', 'right', 'top', 'bottom', 'back', 'front'];\n\nexport function isCubemap(cubemap: any): cubemap is Cubemap {\n    return cubemap && typeof cubemap === 'object' && CUBE_HASHMAP.every((side) => side in cubemap);\n}\n\n/**\n * Given an array of 6 objects in PSV order, returns an array in 3JS order\n */\nexport function cleanCubemapArray<T>(panorama: T[]): T[] {\n    const cleanPanorama: T[] = [];\n\n    if (panorama.length !== 6) {\n        throw new PSVError('A cubemap array must contain exactly 6 images.');\n    }\n\n    // reorder images\n    for (let i = 0; i < 6; i++) {\n        cleanPanorama[i] = panorama[CUBE_ARRAY[i]];\n    }\n\n    return cleanPanorama;\n}\n\n/**\n * Given an object where keys are faces names, retusn an array in 3JS order\n */\nexport function cleanCubemap<T>(cubemap: { [K in CubemapFaces]: T }): T[] {\n    const cleanPanorama: T[] = [];\n\n    if (!isCubemap(cubemap)) {\n        throw new PSVError('A cubemap object must contain exactly left, front, right, back, top, bottom images.');\n    }\n\n    // transform into array\n    CUBE_HASHMAP.forEach((side, i) => {\n        cleanPanorama[i] = (cubemap as any)[side];\n    });\n\n    return cleanPanorama;\n}\n"],"mappings":"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","names":["PSVError","PSVError"]}